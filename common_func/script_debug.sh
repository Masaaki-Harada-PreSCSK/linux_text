#!/bin/bash

# スクリプトを1行ずつ読み込み、実行前に一時停止するスクリプト

# スクリプトファイル自体を読み込む
# ここでは、このスクリプト自身を読み込む例
# 実際の使用では、別のスクリプトファイルを指定することが多いでしょう
#SCRIPT_FILE="$0"
read SCRIPT_FILE

# スクリプトファイルが存在するか確認
if [ ! -f "$SCRIPT_FILE" ]; then
    echo "エラー: スクリプトファイル '$SCRIPT_FILE' が見つかりません。"
    exit 1
fi

# スクリプトファイルを読み込み、各行を処理
# IFS= は内部フィールドセパレータを空にし、read -r はバックスラッシュの解釈を防ぐ
# while read -r line || [[ -n "$line" ]] は、最後の空行でない行も処理するために必要
while IFS= read -r line || [[ -n "$line" ]]; do
    # 空行やコメント行 (# で始まる行) はスキップ
    if [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]]; then
        continue
    fi

    echo "----------------------------------------------------"
    echo "次のコマンドを実行します: $line"
    echo "続行するにはEnterキーを押してください (終了するにはCtrl+C):"
    read -r # ユーザーからの入力を待つ

    # コマンドを実行
    # eval を使用すると、変数の展開やコマンド置換も正しく行われる
    eval "$line"
    
    # コマンドの終了ステータスを表示 (オプション)
    echo "コマンドの終了ステータス: $?"

done < "$SCRIPT_FILE"

echo "----------------------------------------------------"
echo "スクリプトの実行が完了しました。"
